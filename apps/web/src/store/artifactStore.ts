import { create } from 'zustand';\nimport { devtools, subscribeWithSelector } from 'zustand/middleware';\nimport { Artifact, ArtifactCollection } from '@penny/types';\nimport { ArtifactDetector } from '../utils/artifacts/detector';\nimport { ArtifactTransformer } from '../utils/artifacts/transformer';\n\nexport interface User {\n  id: string;\n  name: string;\n  email: string;\n  permissions: string[];\n}\n\nexport interface ArtifactFilter {\n  type?: Artifact['type'][];\n  tags?: string[];\n  createdBy?: string;\n  dateRange?: { start: Date; end: Date };\n  search?: string;\n  isPublic?: boolean;\n}\n\nexport interface ArtifactState {\n  // Data\n  artifacts: Artifact[];\n  collections: ArtifactCollection[];\n  currentUser: User | null;\n  \n  // UI State\n  selectedArtifacts: string[];\n  filter: ArtifactFilter;\n  sortBy: 'createdAt' | 'updatedAt' | 'title' | 'size';\n  sortOrder: 'asc' | 'desc';\n  viewMode: 'grid' | 'list';\n  showSidebar: boolean;\n  \n  // Loading states\n  loading: boolean;\n  creating: boolean;\n  error: string | null;\n  \n  // Actions\n  fetchArtifacts: (options?: { force?: boolean }) => Promise<void>;\n  fetchArtifact: (id: string) => Promise<void>;\n  createArtifact: (data: Omit<Artifact, 'id' | 'createdAt' | 'updatedAt' | 'version'>) => Promise<string>;\n  updateArtifact: (id: string, updates: Partial<Artifact>) => Promise<boolean>;\n  deleteArtifact: (id: string) => Promise<boolean>;\n  duplicateArtifact: (id: string) => Promise<string | null>;\n  \n  // Batch operations\n  bulkDelete: (ids: string[]) => Promise<boolean>;\n  bulkUpdate: (ids: string[], updates: Partial<Artifact>) => Promise<boolean>;\n  bulkExport: (ids: string[], format: string) => Promise<boolean>;\n  \n  // Sharing\n  shareArtifact: (id: string) => Promise<{ shareUrl: string; expiresAt: Date }>;\n  \n  // Collections\n  fetchCollections: () => Promise<void>;\n  createCollection: (data: Omit<ArtifactCollection, 'id' | 'createdAt' | 'updatedAt'>) => Promise<string>;\n  addToCollection: (collectionId: string, artifactIds: string[]) => Promise<boolean>;\n  removeFromCollection: (collectionId: string, artifactIds: string[]) => Promise<boolean>;\n  \n  // Annotations\n  addAnnotation: (artifactId: string, annotation: any) => void;\n  removeAnnotation: (artifactId: string, annotationId: string) => void;\n  updateAnnotation: (artifactId: string, annotationId: string, updates: any) => void;\n  \n  // Filters and sorting\n  setFilter: (filter: Partial<ArtifactFilter>) => void;\n  clearFilter: () => void;\n  setSorting: (sortBy: ArtifactState['sortBy'], sortOrder: ArtifactState['sortOrder']) => void;\n  \n  // Selection\n  selectArtifact: (id: string) => void;\n  deselectArtifact: (id: string) => void;\n  selectAll: () => void;\n  clearSelection: () => void;\n  \n  // UI\n  setViewMode: (mode: 'grid' | 'list') => void;\n  toggleSidebar: () => void;\n  \n  // Import/Upload\n  importArtifacts: (files: FileList) => Promise<string[]>;\n  \n  // Cache management\n  clearCache: () => void;\n  refreshCache: () => Promise<void>;\n}\n\n// Mock API functions\nconst api = {\n  async fetchArtifacts(filter?: ArtifactFilter) {\n    // Mock API call\n    return new Promise<Artifact[]>(resolve => {\n      setTimeout(() => {\n        const mockArtifacts: Artifact[] = [\n          {\n            id: '1',\n            title: 'Sales Dashboard',\n            description: 'Q4 2023 sales performance metrics',\n            type: 'chart',\n            content: {\n              chartType: 'bar',\n              data: [{ month: 'Jan', sales: 100 }, { month: 'Feb', sales: 150 }],\n              config: { title: 'Monthly Sales', responsive: true }\n            },\n            conversationId: 'conv1',\n            messageId: 'msg1',\n            version: 1,\n            size: 1024,\n            tags: ['sales', 'dashboard'],\n            isPublic: false,\n            createdAt: new Date('2023-12-01'),\n            updatedAt: new Date('2023-12-01'),\n            createdBy: 'user1',\n            tenantId: 'tenant1',\n            exportFormats: ['png', 'svg', 'pdf', 'json']\n          },\n          {\n            id: '2',\n            title: 'User Data Table',\n            description: 'Active user statistics',\n            type: 'table',\n            content: {\n              columns: [\n                { key: 'name', title: 'Name', type: 'string', sortable: true, filterable: true },\n                { key: 'email', title: 'Email', type: 'string', sortable: true, filterable: true },\n                { key: 'active', title: 'Active', type: 'boolean', sortable: true, filterable: true }\n              ],\n              data: [\n                { name: 'John Doe', email: 'john@example.com', active: true },\n                { name: 'Jane Smith', email: 'jane@example.com', active: false }\n              ],\n              config: {\n                pagination: { enabled: true, pageSize: 25, showSizeChanger: true },\n                sorting: { enabled: true },\n                filtering: { enabled: true, searchable: true },\n                selection: { enabled: false, multiple: false },\n                export: { enabled: true, formats: ['csv', 'excel'] }\n              }\n            },\n            conversationId: 'conv2',\n            version: 1,\n            size: 2048,\n            tags: ['users', 'data'],\n            isPublic: true,\n            createdAt: new Date('2023-12-02'),\n            updatedAt: new Date('2023-12-02'),\n            createdBy: 'user2',\n            tenantId: 'tenant1',\n            exportFormats: ['csv', 'excel', 'pdf']\n          }\n        ];\n        \n        // Apply filters\n        let filtered = mockArtifacts;\n        \n        if (filter?.type?.length) {\n          filtered = filtered.filter(a => filter.type!.includes(a.type));\n        }\n        \n        if (filter?.tags?.length) {\n          filtered = filtered.filter(a => filter.tags!.some(tag => a.tags.includes(tag)));\n        }\n        \n        if (filter?.search) {\n          const search = filter.search.toLowerCase();\n          filtered = filtered.filter(a => \n            a.title.toLowerCase().includes(search) ||\n            (a.description && a.description.toLowerCase().includes(search))\n          );\n        }\n        \n        resolve(filtered);\n      }, 500);\n    });\n  },\n  \n  async createArtifact(data: any) {\n    return new Promise<string>(resolve => {\n      setTimeout(() => {\n        resolve(Math.random().toString(36).substring(2));\n      }, 300);\n    });\n  },\n  \n  async updateArtifact(id: string, updates: any) {\n    return new Promise<boolean>(resolve => {\n      setTimeout(() => resolve(true), 200);\n    });\n  },\n  \n  async deleteArtifact(id: string) {\n    return new Promise<boolean>(resolve => {\n      setTimeout(() => resolve(true), 200);\n    });\n  },\n  \n  async shareArtifact(id: string) {\n    return new Promise<{ shareUrl: string; expiresAt: Date }>(resolve => {\n      setTimeout(() => {\n        resolve({\n          shareUrl: `/shared/${Math.random().toString(36).substring(2)}`,\n          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days\n        });\n      }, 200);\n    });\n  }\n};\n\nexport const useArtifactStore = create<ArtifactState>()()\n  devtools(\n    subscribeWithSelector((set, get) => ({\n      // Initial state\n      artifacts: [],\n      collections: [],\n      currentUser: {\n        id: 'user1',\n        name: 'Demo User',\n        email: 'demo@penny.ai',\n        permissions: ['create_artifacts', 'edit_artifacts', 'delete_artifacts', 'share_artifacts']\n      },\n      \n      selectedArtifacts: [],\n      filter: {},\n      sortBy: 'createdAt',\n      sortOrder: 'desc',\n      viewMode: 'grid',\n      showSidebar: true,\n      \n      loading: false,\n      creating: false,\n      error: null,\n      \n      // Actions\n      async fetchArtifacts(options) {\n        if (get().loading && !options?.force) return;\n        \n        set({ loading: true, error: null });\n        \n        try {\n          const artifacts = await api.fetchArtifacts(get().filter);\n          \n          // Apply sorting\n          const { sortBy, sortOrder } = get();\n          artifacts.sort((a, b) => {\n            let aVal: any, bVal: any;\n            \n            switch (sortBy) {\n              case 'title':\n                aVal = a.title.toLowerCase();\n                bVal = b.title.toLowerCase();\n                break;\n              case 'size':\n                aVal = a.size || 0;\n                bVal = b.size || 0;\n                break;\n              case 'updatedAt':\n                aVal = a.updatedAt.getTime();\n                bVal = b.updatedAt.getTime();\n                break;\n              default:\n                aVal = a.createdAt.getTime();\n                bVal = b.createdAt.getTime();\n            }\n            \n            const comparison = aVal < bVal ? -1 : aVal > bVal ? 1 : 0;\n            return sortOrder === 'asc' ? comparison : -comparison;\n          });\n          \n          set({ artifacts, loading: false });\n        } catch (error) {\n          set({ \n            error: error instanceof Error ? error.message : 'Failed to fetch artifacts',\n            loading: false \n          });\n        }\n      },\n      \n      async fetchArtifact(id) {\n        const existing = get().artifacts.find(a => a.id === id);\n        if (existing) return;\n        \n        set({ loading: true, error: null });\n        \n        try {\n          // Mock single artifact fetch\n          const artifacts = await api.fetchArtifacts();\n          const artifact = artifacts.find(a => a.id === id);\n          \n          if (artifact) {\n            set(state => ({\n              artifacts: [...state.artifacts.filter(a => a.id !== id), artifact],\n              loading: false\n            }));\n          } else {\n            set({ error: 'Artifact not found', loading: false });\n          }\n        } catch (error) {\n          set({ \n            error: error instanceof Error ? error.message : 'Failed to fetch artifact',\n            loading: false \n          });\n        }\n      },\n      \n      async createArtifact(data) {\n        set({ creating: true, error: null });\n        \n        try {\n          const id = await api.createArtifact(data);\n          \n          const newArtifact: Artifact = {\n            ...data,\n            id,\n            version: 1,\n            size: JSON.stringify(data.content).length,\n            createdAt: new Date(),\n            updatedAt: new Date(),\n            createdBy: get().currentUser?.id || 'anonymous',\n            tenantId: 'tenant1',\n            exportFormats: ArtifactDetector.getSupportedFormats ? [] : []\n          };\n          \n          set(state => ({\n            artifacts: [newArtifact, ...state.artifacts],\n            creating: false\n          }));\n          \n          return id;\n        } catch (error) {\n          set({ \n            error: error instanceof Error ? error.message : 'Failed to create artifact',\n            creating: false \n          });\n          throw error;\n        }\n      },\n      \n      async updateArtifact(id, updates) {\n        set({ error: null });\n        \n        try {\n          const success = await api.updateArtifact(id, updates);\n          \n          if (success) {\n            set(state => ({\n              artifacts: state.artifacts.map(artifact => \n                artifact.id === id \n                  ? { \n                      ...artifact, \n                      ...updates, \n                      updatedAt: new Date(),\n                      version: (artifact.version || 1) + 1\n                    }\n                  : artifact\n              )\n            }));\n          }\n          \n          return success;\n        } catch (error) {\n          set({ error: error instanceof Error ? error.message : 'Failed to update artifact' });\n          return false;\n        }\n      },\n      \n      async deleteArtifact(id) {\n        set({ error: null });\n        \n        try {\n          const success = await api.deleteArtifact(id);\n          \n          if (success) {\n            set(state => ({\n              artifacts: state.artifacts.filter(a => a.id !== id),\n              selectedArtifacts: state.selectedArtifacts.filter(sid => sid !== id)\n            }));\n          }\n          \n          return success;\n        } catch (error) {\n          set({ error: error instanceof Error ? error.message : 'Failed to delete artifact' });\n          return false;\n        }\n      },\n      \n      async duplicateArtifact(id) {\n        const artifact = get().artifacts.find(a => a.id === id);\n        if (!artifact) return null;\n        \n        try {\n          const duplicateId = await get().createArtifact({\n            ...artifact,\n            title: `${artifact.title} (Copy)`,\n            isPublic: false\n          });\n          \n          return duplicateId;\n        } catch (error) {\n          return null;\n        }\n      },\n      \n      async bulkDelete(ids) {\n        set({ error: null });\n        \n        try {\n          // Mock bulk delete\n          const results = await Promise.all(ids.map(id => api.deleteArtifact(id)));\n          const success = results.every(r => r);\n          \n          if (success) {\n            set(state => ({\n              artifacts: state.artifacts.filter(a => !ids.includes(a.id)),\n              selectedArtifacts: state.selectedArtifacts.filter(sid => !ids.includes(sid))\n            }));\n          }\n          \n          return success;\n        } catch (error) {\n          set({ error: error instanceof Error ? error.message : 'Bulk delete failed' });\n          return false;\n        }\n      },\n      \n      async bulkUpdate(ids, updates) {\n        set({ error: null });\n        \n        try {\n          const results = await Promise.all(ids.map(id => api.updateArtifact(id, updates)));\n          const success = results.every(r => r);\n          \n          if (success) {\n            set(state => ({\n              artifacts: state.artifacts.map(artifact => \n                ids.includes(artifact.id)\n                  ? { ...artifact, ...updates, updatedAt: new Date() }\n                  : artifact\n              )\n            }));\n          }\n          \n          return success;\n        } catch (error) {\n          set({ error: error instanceof Error ? error.message : 'Bulk update failed' });\n          return false;\n        }\n      },\n      \n      async bulkExport(ids, format) {\n        // Mock bulk export\n        return true;\n      },\n      \n      async shareArtifact(id) {\n        return await api.shareArtifact(id);\n      },\n      \n      async fetchCollections() {\n        // Mock collections fetch\n        set({ collections: [] });\n      },\n      \n      async createCollection(data) {\n        const id = Math.random().toString(36).substring(2);\n        const collection: ArtifactCollection = {\n          ...data,\n          id,\n          createdAt: new Date(),\n          updatedAt: new Date()\n        };\n        \n        set(state => ({\n          collections: [...state.collections, collection]\n        }));\n        \n        return id;\n      },\n      \n      async addToCollection(collectionId, artifactIds) {\n        set(state => ({\n          collections: state.collections.map(collection => \n            collection.id === collectionId\n              ? { \n                  ...collection, \n                  artifacts: [...new Set([...collection.artifacts, ...artifactIds])],\n                  updatedAt: new Date()\n                }\n              : collection\n          )\n        }));\n        return true;\n      },\n      \n      async removeFromCollection(collectionId, artifactIds) {\n        set(state => ({\n          collections: state.collections.map(collection => \n            collection.id === collectionId\n              ? { \n                  ...collection, \n                  artifacts: collection.artifacts.filter(id => !artifactIds.includes(id)),\n                  updatedAt: new Date()\n                }\n              : collection\n          )\n        }));\n        return true;\n      },\n      \n      addAnnotation(artifactId, annotation) {\n        set(state => ({\n          artifacts: state.artifacts.map(artifact => \n            artifact.id === artifactId\n              ? {\n                  ...artifact,\n                  metadata: {\n                    ...artifact.metadata,\n                    annotations: [\n                      ...(artifact.metadata?.annotations || []),\n                      annotation\n                    ]\n                  }\n                }\n              : artifact\n          )\n        }));\n      },\n      \n      removeAnnotation(artifactId, annotationId) {\n        set(state => ({\n          artifacts: state.artifacts.map(artifact => \n            artifact.id === artifactId\n              ? {\n                  ...artifact,\n                  metadata: {\n                    ...artifact.metadata,\n                    annotations: (artifact.metadata?.annotations || []).filter(\n                      (a: any) => a.id !== annotationId\n                    )\n                  }\n                }\n              : artifact\n          )\n        }));\n      },\n      \n      updateAnnotation(artifactId, annotationId, updates) {\n        set(state => ({\n          artifacts: state.artifacts.map(artifact => \n            artifact.id === artifactId\n              ? {\n                  ...artifact,\n                  metadata: {\n                    ...artifact.metadata,\n                    annotations: (artifact.metadata?.annotations || []).map(\n                      (a: any) => a.id === annotationId ? { ...a, ...updates } : a\n                    )\n                  }\n                }\n              : artifact\n          )\n        }));\n      },\n      \n      setFilter(filter) {\n        set(state => ({ filter: { ...state.filter, ...filter } }));\n        get().fetchArtifacts({ force: true });\n      },\n      \n      clearFilter() {\n        set({ filter: {} });\n        get().fetchArtifacts({ force: true });\n      },\n      \n      setSorting(sortBy, sortOrder) {\n        set({ sortBy, sortOrder });\n        get().fetchArtifacts({ force: true });\n      },\n      \n      selectArtifact(id) {\n        set(state => ({\n          selectedArtifacts: [...new Set([...state.selectedArtifacts, id])]\n        }));\n      },\n      \n      deselectArtifact(id) {\n        set(state => ({\n          selectedArtifacts: state.selectedArtifacts.filter(sid => sid !== id)\n        }));\n      },\n      \n      selectAll() {\n        set(state => ({\n          selectedArtifacts: state.artifacts.map(a => a.id)\n        }));\n      },\n      \n      clearSelection() {\n        set({ selectedArtifacts: [] });\n      },\n      \n      setViewMode(mode) {\n        set({ viewMode: mode });\n      },\n      \n      toggleSidebar() {\n        set(state => ({ showSidebar: !state.showSidebar }));\n      },\n      \n      async importArtifacts(files) {\n        const imported: string[] = [];\n        \n        for (const file of Array.from(files)) {\n          try {\n            const detection = ArtifactDetector.detectFromFile({\n              name: file.name,\n              size: file.size,\n              type: file.type,\n              lastModified: file.lastModified\n            });\n            \n            let content: any;\n            \n            if (file.type.startsWith('image/')) {\n              content = {\n                src: URL.createObjectURL(file),\n                alt: file.name,\n                config: { zoomable: true, downloadable: true }\n              };\n            } else if (file.type === 'application/json') {\n              const text = await file.text();\n              content = JSON.parse(text);\n            } else {\n              const text = await file.text();\n              \n              if (detection.type === 'table' && text.includes(',')) {\n                const result = ArtifactTransformer.toTable(text);\n                content = result.success ? result.data : { raw: text };\n              } else {\n                content = { code: text, language: 'text' };\n              }\n            }\n            \n            const id = await get().createArtifact({\n              title: detection.suggestedTitle || file.name,\n              type: detection.type,\n              content,\n              metadata: detection.metadata,\n              tags: [],\n              isPublic: false\n            });\n            \n            imported.push(id);\n          } catch (error) {\n            console.error(`Failed to import ${file.name}:`, error);\n          }\n        }\n        \n        return imported;\n      },\n      \n      clearCache() {\n        set({ artifacts: [], collections: [] });\n      },\n      \n      async refreshCache() {\n        await get().fetchArtifacts({ force: true });\n        await get().fetchCollections();\n      }\n    })),\n    { name: 'artifact-store' }\n  )\n);\n\n// Selectors\nexport const useArtifactSelectors = () => {\n  const store = useArtifactStore();\n  \n  return {\n    getArtifactById: (id: string) => store.artifacts.find(a => a.id === id),\n    getFilteredArtifacts: () => {\n      const { artifacts, filter } = store;\n      // Additional filtering logic if needed\n      return artifacts;\n    },\n    getSelectedArtifacts: () => {\n      const { artifacts, selectedArtifacts } = store;\n      return artifacts.filter(a => selectedArtifacts.includes(a.id));\n    },\n    getArtifactsByType: (type: Artifact['type']) => {\n      return store.artifacts.filter(a => a.type === type);\n    },\n    getRecentArtifacts: (limit = 10) => {\n      return store.artifacts\n        .sort((a, b) => b.updatedAt.getTime() - a.updatedAt.getTime())\n        .slice(0, limit);\n    }\n  };\n};\n\n// Subscribe to changes\nexport const subscribeToArtifacts = (callback: (artifacts: Artifact[]) => void) => {\n  return useArtifactStore.subscribe(\n    state => state.artifacts,\n    callback,\n    { equalityFn: (a, b) => a.length === b.length && a.every((item, index) => item.id === b[index].id) }\n  );\n};"